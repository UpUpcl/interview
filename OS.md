# 进程与线程

## 进程
进程是CPU分配资源的最小单位
**什么时候创建进程**
1. 系统初始化
2. 正在运行的程序执行了创建进程的系统调用
3. 用户请求创建一个新进程
4. 一个批处理作业的初始化 

**进程的状态**
新建 就绪 运行 阻塞 结束

1. 运行态：该时刻进程持有cpu
2. 就绪态：可以运行，但是由于其他进程运行而暂时停止
3. 阻塞态：除非某种外部事件发生，否则进程不能运行

运行态-->阻塞 ：系统发现进程不能继续运行下去
运行 <--> 阻塞：进程调度程序引起的
阻塞 ---> 就绪：当进程等待的外部事件发生，就会从阻塞态转为就绪态

**PCB控制块**
包括：程序计数器，寄存器，程序状态字，堆栈指针，进程状态，优先级，调度参数，进程ID，父进程，进程组，以及其他在进程由运行态转到就绪态或者阻塞态时必须保存的信息，从而保证该进程随后能在次启动，就像从未被中断一样。

## 线程

## 进程间通信
考虑三个问题：1. 如何把信息传给另一个进程； 2. 如何确保两个或者更多的进程在关键活动中不回出现交叉； 3. 如何保证顺序。
1. 管道：pipline
2. 消息队列：
3. 共享内存：
4. 信号量
5. 套接字：socket

## 进程同步
1. 临界区：对共享内存进行访问的程序段
2. 同步与互斥：
3. 信号量：是一个整型变量，可以执行down和up操作
	down：如果信号量大于0， 执行-1操作；如果信号量等于0，进程睡眠
	up：对信号量+1操作，唤醒睡眠进程让其完成down操作。
	down和up必须是原子操作，在操作时不可以被打断。
4. 管程：在任意一个时刻，管程中只能有一个活跃进程。
5. 屏障技术：屏障用于进程组，可以在每个阶段的结尾安置屏障来实现。当一个进程到达屏障时，它就被屏障阻拦，知道所有进程都到达该屏障为止。

## 调度
当有两个及以上的进程或者线程处于就绪时，就会发生竞争CPU，因此需要调度

**什么时候调度**
1. 创建一个新进程时，父子进程都处于就绪态。此时可以任意决定
2. 当一个进程退出时
3. 当一个进程阻塞在io或者信号量时
4. 发生了io中断

**非抢占式调度** ： 挑选一个进程让该进程运行直到阻塞，或者主动释放CPU
**抢占式调度**：运行固定的时间，如果在时间片结束时还在运行，则该进程被挂起。继续服务下一个就绪态进程。

**调度算法分类**
1. 批处理：没有用户在终端等待一个短请求；因此用非抢占调度
	1. 先来先服务
	2. 最短进程优先
	3. 最短剩余时间有限
2. 交互式
	1. 时间片轮转
	2. 优先级
	3. 最短进程优先
	4. 多级队列：时间片和优先级；进程每一次得到时间片，在其结束后优先级降一级，并且分配的时间片是上一次的2倍。
	5. 保证调度
3. 实时

## 哲学家进餐问题

# 内存管理

## 概念

## 虚拟内存

## 页面置换算法

## 分页系统

## 分段

# 文件系统

## 文件

## 目录

## 文件系统的实现

## 文件系统管理和优化

# 输入/输出

## io硬件原理

## io软件原理

## io软件层次

## 盘

## 时钟

# 死锁

## 资源

## 死锁介绍

## 鸵鸟算法

## 死锁检测和死锁恢复

## 死锁避免

## 死锁预防

# 安全